## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##
######
##
## version $Id: recordMapperBase.vm 1855051 2019-03-08 15:16:28Z tv $
##
## Creates the base peer's mapper class. 
## 
## This template expects the current source element to be a "table" element 
## from the torque schema.
## The schema needs to be processed by the OMTransformer.
## The attributes of the current source element must be set
## as velocity variables.  
##
package ${baseRecordMapperPackage};

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.torque.Column;
import org.apache.torque.TorqueException;
import org.apache.torque.criteria.Criteria;
import org.apache.torque.om.mapper.RecordMapper;

#foreach ($columnElement in $torqueGen.getSourceElement().getChildren("column"))
  #set ($colEnumPackage = $columnElement.getAttribute("enumPackage"))
  #set ($colEnumClassName = $columnElement.getAttribute("enumClassName"))
  #if ($columnElement.getAttribute("isEnum") == "true" && $colEnumPackage != $baseRecordMapperPackage) 
import ${colEnumPackage}.${colEnumClassName};
  #end
#end
#if (${baseRecordMapperPackage} != $dbObjectPackage)
import ${dbObjectPackage}.${dbObjectClassName};
#end
#if (${baseRecordMapperPackage} != $peerPackage)
import ${peerPackage}.${peerClassName};
#end
#if (${baseRecordMapperPackage} != $basePeerPackage)
import ${basePeerPackage}.${basePeerClassName};
#end

#set ( $inheritanceBaseColumnElements = $torqueGen.getChildren("inheritance-column"))
## there should at most be one inheritance-column in each table
#foreach ($inheritanceBaseColumnElement in $inheritanceBaseColumnElements)
  #set ( $columnElement = $inheritanceBaseColumnElement.getChild("column") )
  #set ( $inheritanceElements = $columnElement.getChildren("inheritance"))
  #if ($inheritanceElements.size() > 0)
    #if (${baseRecordMapperPackage} != $dbObjectPackage)
      #foreach ($inheritanceElement in $inheritanceElements)
        #set ( $inheritanceClassName = $inheritanceElement.getAttribute("className") )
import ${dbObjectPackage}.${inheritanceClassName};
      #end
    #end
  #end
#end
/**
 * Maps ResultSet rows into ${dbObjectClassName} objects.
 *
#if ($torqueGen.booleanOption("torque.om.addTimeStamp"))
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [${torqueGen.now()}]
 *
#end
 */
@SuppressWarnings("unused")
public class ${baseRecordMapperClassName} implements RecordMapper<${dbObjectClassName}>
{
#if ($torqueGen.booleanOption("torque.om.addTimeStamp"))
    /** Serial version */
    private static final long serialVersionUID = ${torqueGen.now().Time}L;

#else
    /** Serial version */
    private static final long serialVersionUID = 1L;

#end
    /** The class log. */
    private static Log log
            = LogFactory.getLog(${baseRecordMapperClassName}.class);

    /**
     * Constructs the object from the current row in the resultSet.
     *
     * @param resultSet the resultSet to operate on, already pointing
     *        to the correct row. Not null.
     * @param offset a possible offset in the columns to be considered
     *        (if previous columns contain other objects),
     *        or 0 for no offset.
     * @param criteria The criteria which created the result set.
     *        If set, the attributes to set in the data object
     *        are determined from the select columns in the criteria;
     *        if no matching column can be found, null is returned.
     *        If not set, all of the table's columns are read from the
     *        result set in the order defined in the table definition.
     *
     * @return the mapped object, not null.
     *
     * @throws TorqueException when reading fields from the RecordSet fails
     *         or if a Criteria is passed which contains select columns other
     *         than the columns in the ${name} table.
     */
    public $dbObjectClassName processRow(
                ResultSet resultSet,
                int offset,
                Criteria criteria)
            throws TorqueException
    {
#set ( $inheritanceBaseColumnElement = $torqueGen.getChild("inheritance-column") )
#if ($inheritanceBaseColumnElement)
$torqueGen.mergepoint("createDbObjectInstanceFromInheritance")
#else
$torqueGen.mergepoint("createDbObjectInstance")
#end
#if ($torqueGen.booleanOption("torque.om.trackLoading"))
        try 
        {
            ${field}.setLoading(true);
#end
            if (criteria == null)
            {
#set ( $n = 1 )
#foreach ($columnElement in $torqueGen.getChildren("column"))
  #set ( $setter = $columnElement.getAttribute("setter") )
  #set ( $getter = $columnElement.getAttribute("getter") )
                ${field}.${setter}(
                        ${getter}(resultSet, offset + $n));
  #set ( $n = $n + 1 )
#end
            }
            else
            {
                // try to get columns to be mapped
                // from criteria's select columns
                boolean columnMapped = false;
                int totalOffset = offset + 1;
                List<Column> selectColumns = criteria.getSelectColumns();
                List<Column> columnsWithoutOffset = selectColumns.subList(
                        offset, 
                        selectColumns.size());
                for (Column column : columnsWithoutOffset)
                {
#set ( $else = "" )
#foreach ($columnElement in $torqueGen.getChildren("column"))
  #set ( $setter = $columnElement.getAttribute("setter") )
  #set ( $getter = $columnElement.getAttribute("getter") )
  #set ( $peerColumnName = $columnElement.getAttribute("peerColumnName") )
                    ${else}if (${basePeerClassName}.${peerColumnName}.getSqlExpression().equals(
                            column.getSqlExpression()))
                    {
                        ${field}.${setter}(
                            ${getter}(resultSet, totalOffset));
                        columnMapped = true;
                    }
  #set ( $else = "else ")
#end
                    totalOffset++;
                }
                if (!columnMapped)
                {
                    log.debug("no columns to map found in criteria, "
                        + "returning null");
                    return null;
                }
            }
            ${field}.setNew(false);
            ${field}.setModified(false);
#if ($torqueGen.booleanOption("torque.om.trackLoading"))
        }
        finally
        {
            ${field}.setLoading(false);
        }
#end
        return ${field};
    }

$torqueGen.mergepoint("dbObjectFieldGetters")
}
